<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Set shaders for physically based rendering. — setPBRshaders • rgl2gltf</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="Set shaders for physically based rendering. — setPBRshaders"><meta property="og:description" content='The glTF format is designed to hold objects which
are intended for "physically based rendering", where the
parameters of the object map to physical properties such
as metallicity, roughness, etc.  This function
replaces the default rgl shaders with PBR shaders
based on the reference implementation in
https://github.com/KhronosGroup/glTF-Sample-Viewer/tree/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders.'><meta name="robots" content="noindex"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rgl2gltf</a>
        <span class="version label label-danger" data-toggle="tooltip" data-placement="bottom" title="In-development version">0.1.17</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="../articles/shininess.html">Shininess in OpenGL 1 versus glTF PBR</a>
    </li>
  </ul></li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/dmurdoch/rgl2gltf/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Set shaders for physically based rendering.</h1>
    
    <div class="hidden name"><code>setPBRshaders.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>The glTF format is designed to hold objects which
are intended for "physically based rendering", where the
parameters of the object map to physical properties such
as metallicity, roughness, etc.  This function
replaces the default <span class="pkg">rgl</span> shaders with PBR shaders
based on the reference implementation in
<a href="https://github.com/KhronosGroup/glTF-Sample-Viewer/tree/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders" class="external-link">https://github.com/KhronosGroup/glTF-Sample-Viewer/tree/88eda8c5358efe03128b72b6c5f5f6e5b6d023e1/shaders</a>.</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="fu">setPBRshaders</span><span class="op">(</span><span class="va">gltf</span>, <span class="va">gltfMat</span>, <span class="va">id</span>,
              scene <span class="op">=</span> <span class="fu"><a href="https://dmurdoch.github.io/rgl/dev/reference/scene3d.html" class="external-link">scene3d</a></span><span class="op">(</span>minimal <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,
              useIBL <span class="op">=</span> <span class="cn">TRUE</span>,
              brdfLUT <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html" class="external-link">system.file</a></span><span class="op">(</span><span class="st">"textures/brdfLUT.png"</span>, package <span class="op">=</span> <span class="st">"rgl2gltf"</span><span class="op">)</span>,
              IBLspecular <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html" class="external-link">system.file</a></span><span class="op">(</span><span class="st">"textures/refmap.png"</span>, package <span class="op">=</span> <span class="st">"rgl"</span><span class="op">)</span>,
              IBLdiffuse <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html" class="external-link">system.file</a></span><span class="op">(</span><span class="st">"textures/refmapblur.jpeg"</span>, package <span class="op">=</span> <span class="st">"rgl2gltf"</span><span class="op">)</span>,
              debugBaseColor <span class="op">=</span> <span class="fl">0</span>,
              debugMetallic <span class="op">=</span> <span class="fl">0</span>,
              debugRoughness <span class="op">=</span> <span class="fl">0</span>,
              debugSpecularReflection <span class="op">=</span> <span class="fl">0</span>,
              debugGeometricOcclusion <span class="op">=</span> <span class="fl">0</span>,
              debugMicrofacetDistribution <span class="op">=</span> <span class="fl">0</span>,
              debugSpecContrib <span class="op">=</span> <span class="fl">0</span>,
              debugDiffuseContrib <span class="op">=</span> <span class="fl">0</span>,
              debugIBLDiffuse <span class="op">=</span> <span class="fl">1</span>,
              debugIBLSpecular <span class="op">=</span> <span class="fl">1</span>,
              defines <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>,
              uniforms <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>,
              attributes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span>,
              textures <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></code></pre></div>
    </div>

    <div id="arguments">
    <h2>Arguments</h2>
    <dl><dt>gltf, gltfMat</dt>
<dd><p>A <code>"gltf"</code> object, and a material record from it.</p></dd>
<dt>id, scene</dt>
<dd><p>The <span class="pkg">rgl</span> id of the corresponding object and the scene holding it.</p></dd>
<dt>useIBL</dt>
<dd><p>Whether to use image based lighting.</p></dd>
<dt>brdfLUT</dt>
<dd><p>The texture to use for the "bidirectional reflectance distribution
function" lookup table.</p></dd>
<dt>IBLspecular</dt>
<dd><p>The texture to use for the "image based specular lighting".</p></dd>
<dt>IBLdiffuse</dt>
<dd><p>The texture to use for the "image based diffuse lighting".</p></dd>
<dt>debugBaseColor, debugMetallic, debugRoughness,
       debugSpecularReflection, debugGeometricOcclusion,
       debugMicrofacetDistribution, debugSpecContrib,
       debugDiffuseContrib</dt>
<dd><p>These are flags used for debugging.  Setting one of these to
1 will display just that contribution to the rendering.</p></dd>
<dt>debugIBLDiffuse,
       debugIBLSpecular</dt>
<dd><p>Two more debugging settings.  These should be set to non-negative
values to control the contribution from each of those components
to the image based lighting.</p></dd>
<dt>defines, uniforms, attributes, textures</dt>
<dd><p>Values to use in <code><a href="https://dmurdoch.github.io/rgl/dev/reference/setUserShaders.html" class="external-link">setUserShaders</a></code> in addition
to the ones determined by this function.</p></dd>
</dl></div>
    <div id="details">
    <h2>Details</h2>
    <p><span class="pkg">rgl</span> is designed to work with WebGL version 1, which doesn't
support all of the features used in the reference shaders.  In
particular, no extensions are assumed, and the IBL textures are
single 2D textures rather than cube maps.</p>
    </div>
    <div id="value">
    <h2>Value</h2>
    <p>This function modifies the <code>id</code> object in <code>scene</code>,
and returns the modified scene.</p>
    </div>
    <div id="references">
    <h2>References</h2>
    <p><a href="https://github.com/KhronosGroup/glTF-Sample-Viewer" class="external-link">https://github.com/KhronosGroup/glTF-Sample-Viewer</a></p>
    </div>
    <div id="author">
    <h2>Author</h2>
    <p>Duncan Murdoch for the adaptation to <span class="pkg">rgl</span>, various
others for the original shaders.</p>
    </div>
    <div id="see-also">
    <h2>See also</h2>
    <div class="dont-index"><p><code><a href="gltfWidget.html">gltfWidget</a></code></p></div>
    </div>

    <div id="ref-examples">
    <h2>Examples</h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"></span>
<span class="r-in"><span class="co"># This web page has lots of sample files</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="va">samples</span> <span class="op">&lt;-</span> <span class="st">"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0"</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="co"># Get one of them:  a 2 cylinder engine</span></span>
<span class="r-in"></span>
<span class="r-in"><span class="va">gltf</span> <span class="op">&lt;-</span> <span class="fu"><a href="readGLB.html">readGLB</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="va">samples</span>, <span class="st">"/NormalTangentTest/glTF-Binary/NormalTangentTest.glb?raw=true"</span><span class="op">)</span><span class="op">)</span></span>
<span class="r-in"><span class="va">gltfMat</span> <span class="op">&lt;-</span> <span class="va">gltf</span><span class="op">$</span><span class="fu">getMaterial</span><span class="op">(</span><span class="fl">0</span><span class="op">)</span></span>
<span class="r-in"><span class="va">scene</span> <span class="op">&lt;-</span> <span class="fu"><a href="imports.html">as.rglscene</a></span><span class="op">(</span><span class="va">gltf</span><span class="op">)</span></span>
<span class="r-in"><span class="va">id</span> <span class="op">&lt;-</span> <span class="va">scene</span><span class="op">$</span><span class="va">objects</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">id</span></span>
<span class="r-in"><span class="va">scene</span> <span class="op">&lt;-</span> <span class="fu">setPBRshaders</span><span class="op">(</span><span class="va">gltf</span>, <span class="va">gltfMat</span>, <span class="va">id</span>, <span class="va">scene</span><span class="op">)</span></span>
<span class="r-in"><span class="fu"><a href="https://rdrr.io/r/base/cat.html" class="external-link">cat</a></span><span class="op">(</span><span class="va">scene</span><span class="op">$</span><span class="va">objects</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span><span class="op">$</span><span class="va">userFragmentShader</span><span class="op">)</span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #define HAS_UV 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #define HAS_NORMALS 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #define HAS_BASECOLORMAP 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #define HAS_NORMALMAP 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #define HAS_TANGENTS 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #define HAS_METALROUGHNESSMAP 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #define HAS_OCCLUSIONMAP 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #define USE_IBL 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #define MANUAL_SRGB 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> //</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // This fragment shader defines a reference implementation for Physically Based Shading of</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // a microfacet surface material defined by a glTF model.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> //</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // References:</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // [1] Real Shading in Unreal Engine 4</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> //     http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // [2] Physically Based Shading at Disney</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> //     http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // [3] README.md - Environment Maps</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> //     https://github.com/KhronosGroup/glTF-Sample-Viewer/#environment-maps</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // [4] "An Inexpensive BRDF Model for Physically based Rendering" by Christophe Schlick</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> //     https://www.cs.virginia.edu/~jdl/bib/appearance/analytic%20models/schlick94b.pdf</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef GL_ES</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef GL_FRAGMENT_PRECISION_HIGH</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   precision highp float;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #else</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   precision mediump float;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform vec3 lightDir0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform vec3 u_LightColor;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef USE_IBL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform sampler2D u_DiffuseEnvSampler;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform sampler2D u_SpecularEnvSampler;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform sampler2D u_brdfLUT;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // debugging flag</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform vec2 u_ScaleIBLAmbient;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_BASECOLORMAP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform sampler2D uSampler;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_NORMALMAP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform sampler2D normalTexture;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform float u_NormalScale;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_EMISSIVEMAP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform sampler2D u_EmissiveSampler;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform vec3 u_EmissiveFactor;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_METALROUGHNESSMAP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform sampler2D u_MetallicRoughnessSampler;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_OCCLUSIONMAP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform sampler2D u_OcclusionSampler;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform float u_OcclusionStrength;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform vec2 u_MetallicRoughnessValues;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> varying vec4 vCol;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // debugging flags used for shader output of intermediate PBR variables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform vec4 u_ScaleDiffBaseMR;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> uniform vec4 u_ScaleFGDSpec;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> varying vec4 vPosition;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> varying vec2 vTexcoord;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_NORMALS</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_TANGENTS</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> varying mat3 vtbnMatrix;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #else</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> varying vec3 vNormal;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Encapsulate the various inputs used by the various functions in the shading equation</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // We store values in this struct to simplify the integration of alternative implementations</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // of the shading terms, outlined in the Readme.MD Appendix.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> struct PBRInfo</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float NdotL;                  // cos angle between normal and light direction</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float NdotV;                  // cos angle between normal and view direction</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float NdotH;                  // cos angle between normal and half vector</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float LdotH;                  // cos angle between light direction and half vector</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float VdotH;                  // cos angle between view direction and half vector</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float metalness;              // metallic value at the surface</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 reflectance0;            // full reflectance color (normal incidence angle)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 reflectance90;           // reflectance color at grazing angle</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 diffuseColor;            // color contribution from diffuse lighting</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 specularColor;           // color contribution from specular lighting</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> };</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> const float M_PI = 3.141592653589793;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> const float c_MinRoughness = 0.04;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vec4 SRGBtoLINEAR(vec4 srgbIn)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     #ifdef MANUAL_SRGB</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     #ifdef SRGB_FAST_APPROXIMATION</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 linOut = pow(srgbIn.xyz,vec3(2.2));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     #else //SRGB_FAST_APPROXIMATION</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 bLess = step(vec3(0.04045),srgbIn.xyz);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     #endif //SRGB_FAST_APPROXIMATION</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return vec4(linOut,srgbIn.w);;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     #else //MANUAL_SRGB</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return srgbIn;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     #endif //MANUAL_SRGB</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Find the normal for this fragment, pulling either from a predefined normal map</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // or from the interpolated mesh normal and tangent attributes.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vec3 getNormal()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Retrieve the tangent space matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifndef HAS_TANGENTS</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_EXTENSIONS</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 pos_dx = dFdx(vPosition.xyz);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 pos_dy = dFdy(vPosition.xyz);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 tex_dx = dFdx(vec3(vTexcoord, 0.0));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 tex_dy = dFdy(vec3(vTexcoord, 0.0));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #else</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 pos_dx = vec3(1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 pos_dy = vec3(1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 tex_dx = vec3(1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 tex_dy = vec3(1);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_NORMALS</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 ng = normalize(vNormal);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #else</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 ng = cross(pos_dx, pos_dy);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     t = normalize(t - ng * dot(ng, t));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 b = normalize(cross(ng, t));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mat3 tbn = mat3(t, b, ng);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #else // HAS_TANGENTS</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     mat3 tbn = vtbnMatrix;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_NORMALMAP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 n = texture2D(normalTexture, vTexcoord).rgb;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #else</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // The tbn matrix is linearly interpolated, so we need to re-normalize</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 n = normalize(tbn[2].xyz);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return n;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Calculation of the lighting contribution from an optional Image Based Light source.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // See our README.md on Environment Maps [3] for additional discussion.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef USE_IBL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float mipCount = 9.0; // resolution of 512x512</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float lod = (pbrInputs.perceptualRoughness * mipCount);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // retrieve a scale and bias to F0. See [1], Figure 3</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT, vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec2 latlong1 = vec2(asin(n.z)/M_PI + 0.5,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          atan(n.y, n.x)/2.0/M_PI + 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 diffuseLight = SRGBtoLINEAR(texture2D(u_DiffuseEnvSampler, latlong1)).rgb;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef USE_TEX_LOD</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 specularLight = SRGBtoLINEAR(textureCubeLodEXT(u_SpecularEnvSampler, reflection, lod)).rgb;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #else</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec2 latlong2 = vec2(asin(reflection.z)/M_PI + 0.5,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                          atan(reflection.y, reflection.x)/2.0/M_PI + 0.5);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 specularLight = SRGBtoLINEAR(texture2D(u_SpecularEnvSampler, latlong2.xy)).rgb;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // For presentation, this allows us to disable IBL terms</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     diffuse *= u_ScaleIBLAmbient.x;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     specular *= u_ScaleIBLAmbient.y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return diffuse + specular;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Basic Lambertian diffuse</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // See also [1], Equation 1</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vec3 diffuse(PBRInfo pbrInputs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return pbrInputs.diffuseColor / M_PI;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // The following equation models the Fresnel reflectance term of the spec equation (aka F())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Implementation of fresnel from [4], Equation 15</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> vec3 specularReflection(PBRInfo pbrInputs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // This calculates the specular geometric attenuation (aka G()),</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // where rougher material will reflect less light back to the viewer.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // This implementation is based on [1] Equation 4, and we adopt their modifications to</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // alphaRoughness as input as originally proposed in [2].</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> float geometricOcclusion(PBRInfo pbrInputs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float NdotL = pbrInputs.NdotL;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float NdotV = pbrInputs.NdotV;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float r = pbrInputs.alphaRoughness;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return attenuationL * attenuationV;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Implementation from "Average Irregularity Representation of a Roughened Surface for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> // Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> float microfacetDistribution(PBRInfo pbrInputs)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     return roughnessSq / (M_PI * f * f);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> void main()</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Metallic and Roughness material properties are packed together</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // In glTF, these factors can be specified by fixed scalar values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // or from a metallic-roughness map</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float perceptualRoughness = u_MetallicRoughnessValues.y;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float metallic = u_MetallicRoughnessValues.x;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_METALROUGHNESSMAP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // This layout intentionally reserves the 'r' channel for (optional) occlusion map data</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec4 mrSample = texture2D(u_MetallicRoughnessSampler, vTexcoord);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     perceptualRoughness = mrSample.g * perceptualRoughness;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     metallic = mrSample.b * metallic;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     metallic = clamp(metallic, 0.0, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Roughness is authored as perceptual roughness; as is convention,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // convert to material roughness by squaring the perceptual roughness [2].</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float alphaRoughness = perceptualRoughness * perceptualRoughness;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // The albedo may be defined from a base texture or a flat color</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_BASECOLORMAP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec4 baseColor = SRGBtoLINEAR(texture2D(uSampler, vTexcoord)) * vCol;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #else</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec4 baseColor = vCol;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 f0 = vec3(0.04);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     diffuseColor *= 1.0 - metallic;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 specularColor = mix(f0, baseColor.rgb, metallic);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Compute reflectance.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 specularEnvironmentR0 = specularColor.rgb;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 n = getNormal();                             // normal at surface point</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 v = normalize(- vPosition.xyz);        // Vector from surface point to camera</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 l = normalize(lightDir0);                    // Vector from surface point to light</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 h = normalize(l+v);                          // Half vector between both l and v</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 reflection = -normalize(reflect(v, n));</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float NdotL = clamp(dot(n, l), 0.001, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float NdotH = clamp(dot(n, h), 0.0, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float LdotH = clamp(dot(l, h), 0.0, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float VdotH = clamp(dot(v, h), 0.0, 1.0);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     PBRInfo pbrInputs = PBRInfo(</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         NdotL,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         NdotV,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         NdotH,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         LdotH,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         VdotH,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         perceptualRoughness,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         metallic,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         specularEnvironmentR0,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         specularEnvironmentR90,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         alphaRoughness,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         diffuseColor,</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         specularColor</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     );</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Calculate the shading terms for the microfacet specular shading model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 F = specularReflection(pbrInputs);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float G = geometricOcclusion(pbrInputs);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float D = microfacetDistribution(pbrInputs);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Calculation of analytical lighting contribution</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 color = NdotL * u_LightColor * (diffuseContrib + specContrib);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Calculate lighting contribution from image based lighting source (IBL)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef USE_IBL</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     color += getIBLContribution(pbrInputs, n, reflection);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // Apply optional PBR terms for additional (optional) shading</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_OCCLUSIONMAP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     float ao = texture2D(u_OcclusionSampler, vTexcoord).r;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     color = mix(color, color * ao, u_OcclusionStrength);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #ifdef HAS_EMISSIVEMAP</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, vTexcoord)).rgb * u_EmissiveFactor;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     color += emissive;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> #endif</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // This section uses mix to override final color for reference app visualization</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     // of various parameters in the lighting equation.</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     color = mix(color, F, u_ScaleFGDSpec.x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     color = mix(color, vec3(G), u_ScaleFGDSpec.y);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     color = mix(color, vec3(D), u_ScaleFGDSpec.z);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     color = mix(color, specContrib, u_ScaleFGDSpec.w);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     color = mix(color, diffuseContrib, u_ScaleDiffBaseMR.x);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     gl_FragColor = vec4(pow(color,vec3(1.0/2.2)), baseColor.a);</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
</code></pre></div>
    </div>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by <a href="https://github.com/dmurdoch" class="external-link">Duncan
Murdoch</a>.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a>
2.0.2.9000.</p>
</div>

      </footer></div>

  


  

  </body></html>

